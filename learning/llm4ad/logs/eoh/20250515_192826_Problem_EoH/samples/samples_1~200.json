[
    {
        "sample_order": 1,
        "algorithm": "{The algorithm calculates priority scores for each bin by first determining the remaining capacity after adding the item, then prioritizing bins with the smallest remaining capacity if the item fits, otherwise assigning zero priority.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining = bins - item\n    valid = remaining >= 0\n    priority_scores = np.where(valid, -remaining, 0)\n    return priority_scores\n\n",
        "score": -2091.8
    },
    {
        "sample_order": 2,
        "algorithm": "{\\it Prioritize bins with the least remaining capacity that can still accommodate the item, ensuring efficient space utilization.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining = bins - item\n    valid = remaining >= 0\n    priority_scores = np.where(valid, remaining, np.inf)\n    return priority_scores\n\n",
        "score": -5000.0
    },
    {
        "sample_order": 3,
        "algorithm": "{The algorithm calculates priority scores for each bin by first normalizing the remaining capacity after adding the item, then applying a sigmoid function to emphasize bins with capacities close to the item size.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining_capacity = bins - item\n    normalized = remaining_capacity / np.max(np.abs(remaining_capacity))\n    sigmoid = 1 / (1 + np.exp(-normalized))\n    return sigmoid\n\n",
        "score": -5000.0
    },
    {
        "sample_order": 4,
        "algorithm": "{The algorithm calculates priority scores for each bin by first normalizing the remaining capacity after adding the item, then prioritizing bins with the least remaining capacity to minimize wasted space.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining_capacity = bins - item\n    valid_bins = remaining_capacity >= 0\n    priority_scores = np.where(valid_bins, 1 / (remaining_capacity + 1e-10), -np.inf)\n    return priority_scores\n\n",
        "score": -2091.8
    },
    {
        "sample_order": 5,
        "algorithm": "{The algorithm calculates priority scores by considering the ratio of the item size to the bin's remaining capacity, prioritizing bins where the item would fill the largest proportion of remaining space, with zero priority for bins that can't accommodate the item.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining = bins - item\n    valid = remaining >= 0\n    priority_scores = np.where(valid, item / (remaining + 1e-10), 0)\n    return priority_scores\n\n",
        "score": -2091.8
    },
    {
        "sample_order": 6,
        "algorithm": "{\\it Prioritize bins with the largest remaining capacity that can still accommodate the item, ensuring balanced space utilization.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining = bins - item\n    valid = remaining >= 0\n    priority_scores = np.where(valid, remaining, -np.inf)\n    return priority_scores\n\n",
        "score": -5000.0
    },
    {
        "sample_order": 7,
        "algorithm": "{The algorithm calculates priority scores for each bin by first determining the remaining capacity after adding the item, then prioritizing bins with the largest remaining capacity if the item fits, otherwise assigning zero priority.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining = bins - item\n    valid = remaining >= 0\n    priority_scores = np.where(valid, remaining, 0)\n    return priority_scores\n\n",
        "score": -5000.0
    },
    {
        "sample_order": 8,
        "algorithm": "{\\it Prioritize bins with the most remaining capacity after accommodating the item, promoting balanced load distribution.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining = bins - item\n    valid = remaining >= 0\n    priority_scores = np.where(valid, -remaining, np.inf)\n    return priority_scores\n\n",
        "score": -2091.8
    },
    {
        "sample_order": 9,
        "algorithm": "{The algorithm calculates priority scores for each bin by first determining the ratio of the item size to the bin's remaining capacity, then prioritizing bins with the smallest ratio if the item fits, otherwise assigning zero priority.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining = bins - item\n    valid = remaining >= 0\n    ratio = np.where(valid, item / bins, 0)\n    priority_scores = np.where(valid, -ratio, 0)\n    return priority_scores\n\n",
        "score": -5000.0
    },
    {
        "sample_order": 10,
        "algorithm": "{Calculate remaining capacity after adding the item, prioritize bins where the item fits by their remaining capacity, and assign zero priority to bins where it doesn't fit.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining = bins - item\n    valid = remaining >= 0\n    priority_scores = np.where(valid, remaining, 0)\n    return priority_scores\n\n",
        "score": -5000.0
    },
    {
        "sample_order": 11,
        "algorithm": "{The algorithm calculates priority scores for each bin by first determining the remaining capacity after adding the item, then prioritizing bins with the largest remaining capacity if the item fits, otherwise assigning zero priority.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining = bins - item\n    valid = remaining >= 0\n    priority_scores = np.where(valid, remaining, 0)\n    return priority_scores\n\n",
        "score": -5000.0
    },
    {
        "sample_order": 12,
        "algorithm": "{The new algorithm calculates priority scores for each bin by first determining the remaining capacity after adding the item, then prioritizing bins with the largest remaining capacity if the item fits, otherwise assigning zero priority.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining = bins - item\n    valid = remaining >= 0\n    priority_scores = np.where(valid, remaining, 0)\n    return priority_scores\n\n",
        "score": -5000.0
    },
    {
        "sample_order": 13,
        "algorithm": "{The algorithm prioritizes bins based on their current capacity relative to the item size, favoring bins with capacities closest to twice the item size to balance between space utilization and flexibility.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    target = 2 * item\n    priority_scores = -np.abs(bins - target)\n    return priority_scores\n\n",
        "score": -2626.4
    },
    {
        "sample_order": 14,
        "algorithm": "{\\it Prioritize bins with the largest capacity that can still accommodate the item, promoting balanced load distribution.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining = bins - item\n    valid = remaining >= 0\n    priority_scores = np.where(valid, bins, -np.inf)\n    return priority_scores\n\n",
        "score": -5000.0
    },
    {
        "sample_order": 15,
        "algorithm": "{The algorithm calculates priority scores for each bin by first determining the remaining capacity after adding the item, then prioritizing bins with the largest remaining capacity if the item fits, otherwise assigning zero priority.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining = bins - item\n    valid = remaining >= 0\n    priority_scores = np.where(valid, remaining, 0)\n    return priority_scores\n\n",
        "score": -5000.0
    },
    {
        "sample_order": 16,
        "algorithm": "{The new algorithm calculates priority scores for each bin by first determining the remaining capacity after adding the item, then prioritizing bins with the largest remaining capacity if the item fits, otherwise assigning zero priority.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining = bins - item\n    valid = remaining >= 0\n    priority_scores = np.where(valid, remaining, 0)\n    return priority_scores\n\n",
        "score": -5000.0
    },
    {
        "sample_order": 17,
        "algorithm": "{The algorithm prioritizes bins based on the ratio of the item size to the bin's remaining capacity, favoring bins where the item size is a larger fraction of the remaining space, while ignoring bins that cannot fit the item.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining = bins - item\n    valid = remaining >= 0\n    priority_scores = np.where(valid, item / (remaining + 1e-10), -np.inf)\n    return priority_scores\n\n",
        "score": -2091.8
    },
    {
        "sample_order": 18,
        "algorithm": "{The algorithm prioritizes bins based on the ratio of the item size to the bin's current capacity, favoring bins where the item size is a larger fraction of the remaining space.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    valid = bins >= item\n    priority_scores = np.where(valid, item / bins, 0)\n    return priority_scores\n\n",
        "score": -2091.8
    },
    {
        "sample_order": 19,
        "algorithm": "{The algorithm prioritizes bins based on their remaining capacity relative to the item size, favoring bins with capacities closest to the item size to maximize space utilization while minimizing wasted space.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priority_scores = -np.abs(bins - item)\n    return priority_scores\n\n",
        "score": -2091.8
    },
    {
        "sample_order": 20,
        "algorithm": "{The new algorithm calculates priority scores for each bin by first determining the remaining capacity after adding the item, then prioritizing bins with the largest remaining capacity if the item fits, otherwise assigning zero priority.}",
        "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    remaining = bins - item\n    valid = remaining >= 0\n    priority_scores = np.where(valid, remaining, 0)\n    return priority_scores\n\n",
        "score": -5000.0
    }
]