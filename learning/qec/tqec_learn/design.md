---

# 主要 TQEC 设计文档

## 状态

草稿 / 提议 / 已接受 / 已实现 / 已废弃

## 目标

我们在做什么，为什么要这么做？这将解决什么问题？目标与非目标是什么？这里是您的执行摘要；请保持简短，详细内容见下文。

我们计划构建工具，以便对受拓扑量子纠错（TQEC）保护的复杂计算进行深入研究。目前现有工具很少，且功能有限，这意味着 TQEC 的大量理论仅以论文中的图示形式存在，并未经过充分测试。没有测试能力，就很难改进理论，更不用说在实际硬件上大规模实现它。改进理论和在实际硬件上大规模实现是我们的明确目标。我们的初始重点将放在二维量子比特阵列上。关于具有远程相互作用的体系结构的支持将在完成二维阵列工具后再讨论。

## 动机

解决这个问题有什么价值？需要哪些背景信息来说明本设计如何解决问题？
哪些用户会受到这个问题的影响？为什么这是一个问题？有哪些数据支持这一点？存在哪些相关工作？

很难想象不使用纠错的量子计算机能够执行那些在经典硬件上更便宜、更好地完成的有用计算。整个量子计算领域将依赖于良好的工具，以纠错的方式编译和优化算法。对于我们的初始重点——二维体系结构来说，这首先意味着需要深入理解表面码（surface code），这是此类体系结构中最领先的量子纠错框架。对于致力于表面码研究的学者而言，目前缺乏先进工具已成为改进理论的巨大障碍。工具的缺乏使得验证某些思想是否正确变得困难。例如，最早关于表面码的论文中使用的电路实际上并未起作用，因为它们在纠缠相邻测量量子比特时存在问题。

**相关工作：**
[https://github.com/qc-design/plaquette](https://github.com/qc-design/plaquette)

## 用户收益

用户（或其他贡献者）将如何从这项工作中受益？发布说明、博客文章或论文中的标题会是什么？

我们构建的工具旨在使用户更容易学习 TQEC，同时验证受 TQEC 保护的结构的设计是否有效，并且是否优于现有结构。在构建这些工具的过程中，预计贡献者会发表一系列由这些工具驱动的原创研究论文，既推动该领域的发展，又为其他人提供入门示例。例如，第一篇论文研究“表面码中数据的长距离传输”是非常合理的。

---

# 设计方案

这部分是文档的核心，您需要在此详细阐述您的方案。如果有多个方案，请务必使用子章节以更好地分隔思路，并列出每种方案的优缺点。如果有已排除的替代方案，也请在此列出并解释为什么认为所选方案更优。

请确保您已经考虑并涵盖以下各部分。如果某部分与您的具体方案无关，请说明原因（例如，您的方案讨论的是一种约定或流程，而非 API）。

目前假设的功能概览见本演示文稿的幻灯片 20-32。若能由社区将其转化为设计方案将是极好的。

根据目前掌握的信息和理解，我对整个工具的设想如下：
（下图为说明瓷砖构建工具如何运作的示意图。）

---

## 设计方案 #1

本文件描述了我脑海中对工具设计的构想，以及我们可能需要的一些相关资源。
这只是一个提议，欢迎大家评论或直接编辑此部分。

### 用户界面

正如 Austin 在多次演讲中指出的，工具应当非常友好，并尽可能减少用户需要编写代码的量。这意味着，每个作为目标列出的任务应尽可能通过易用的图形用户界面（GUI）来实现。

二维表面码的表示方式让我联想到纯二维（即非等距二维游戏，而是自上而下的普通二维）游戏。以下是我认为二维 QEC 码与二维游戏之间的几个对应关系：

| 普通二维游戏                               | 二维 QEC 码可视化                          |
| ------------------------------------------ | ------------------------------------------ |
| 资产，排列在游戏地图上                     | 小方块（plaquettes），排列在量子比特上     |
| 资产库，游戏设计师可以从中选择构建游戏地图 | 小方块库，QEC 研究人员可以从中选择构建代码 |
| 网格，表示可放置资产的位置                 | 硬件拓扑，表示小方块可放置的量子比特位置   |

而且这种对应关系不止于此。游戏中的网格和资产可以采用六边形或方形铺排（两种最常用的铺排方式），这可以用来表示目标芯片的硬件拓扑以及小方块中量子比特之间的连接。

正因为看到了这么多的对应关系，我相信我们可以借鉴大量开源二维游戏编辑器的经验，通过这些工具中反复迭代和反馈所形成的经验，获得一个既美观又实用的用户界面。

我认为我们无法令人满意地使用现有的库，原因如下：

- 我查阅过的一些库都是专为游戏设计而开发的。其中一些看起来非常灵活，但其设计从一开始就仅考虑了二维游戏。例如，它们的资产只是普通图像，除此之外没有更多信息。虽然可以为资产添加元数据，但可添加的元数据种类受限且严重偏向游戏（例如旋转资产时使用的中心点）。
- 这些二维游戏设计库包含许多我们根本不需要的花里胡哨的功能，比如连接数据库、使用第三方代码链接资产等。

尽管如此，用于开发 UI 的一些理念对我们依然具有参考价值。

目前我的设想是，用户界面将包含以下元素：

- **新建小方块面板**：用于创建新的小方块并将其添加到小方块库中。这包括对小方块上量子比特的索引、为 QEC 执行的每一层提供相应的量子电路，以及可能还有其他我暂时忘记或尚未考虑的内容。
- **新建小方块模板面板**：用于创建新的小方块模板并将其添加到小方块模板库中。小方块模板实际上是由小方块库中的小方块按一定规则排列而成的结构，可以按比例缩放。具体的缩放行为可能需要通过代码来描述。
- **编辑 QEC 码面板**：该面板将包含一个仪表盘或侧边栏，用于快速访问小方块模板库，就像二维游戏中可以快速访问不同资产一样。该面板还将包含多个按钮，用于执行复制/剪切/粘贴、删除小方块模板等操作。
- **编辑测量含义面板**：也就是说，一个用于说明“此测量结果为 |1> 对应检测事件”或“此测量与另一测量结果不同对应检测事件”的面板。这部分很可能不会由用户手动完成，而是通过预定义的小方块之间的关系自动生成。

小方块模板在大多数图像编辑器中的行为类似：当用户点击已放置在网格上的模板时，该模板将被选中。选中后，模板的四周会出现几个可视化控制点。用户可以拖动这些控制点来对模板进行缩放（放大或缩小）。在模板的其他区域点击并拖动则可以移动该模板在网格中的位置。

### 底层数据结构

#### 拓扑结构

我们需要有一种方式来以不同的结构表示硬件拓扑：

- 在小方块的数据结构中，用以编码小方块所假设的拓扑结构。
- 在表示我们应用代码的硬件网格上。

在我（Adrien Suau）的观点中，我们可能需要区分：

- **“无限”拓扑**：代表我们将要处理的量子比特及其连接关系；
- **“有限”拓扑**：代表一个小方块或小方块模板所需要的拓扑结构。

这样可以使我们：

- 为一组预定义的拓扑（如最近邻、环形、线性、重六边形等）构建多个表示“无限”拓扑的类。需要其他“无限”拓扑的用户仍可以通过编程实现。
- 定义一个类来表示“有限”拓扑。

“无限”与“有限”拓扑也可以被视作不同的对象：

- “无限”拓扑表示底层硬件的拓扑，因此在软件运行时不能动态改变。
- “有限”拓扑则代表某个小方块（或小方块模板）的拓扑要求。

根据这些定义，“有限”与“无限”拓扑只有在检查某个拓扑要求（即有限拓扑）是否被某一部分“无限”拓扑（即硬件拓扑）满足时才会相互作用。
注意，我们还需要一个坐标系统来精确确定量子比特的位置。

#### 小方块（Plaquette）

每个小方块需要包含以下信息：

- 它的拓扑要求。
- 综合症（syndrome）量子比特。
- 数据量子比特。
- 用于测量稳定子（stabilizer）的量子电路。
- 用于表示小方块的图形表示（例如 SVG 格式）。

能够根据拓扑将小方块“贴附”到底层网格上将是非常理想的。

#### 小方块模板

每个小方块模板需要包含：

- 其所要求的拓扑结构，该拓扑结构由构成模板的小方块的要求拓扑决定。
- 构成模板的不同小方块。
- 如何将模板扩展到更大尺寸的方案。

小方块模板的缩放将是一个具有挑战性的问题。目前我能想到两种实现方式：

1. 用户需要通过编程定义若干函数，以模板的缩放比例作为参数。其中一个函数需要描述在给定缩放比例下的小方块模板。
2. 通过图形化方式描述缩放过程。

目前，我认为第一种编程方式是最佳选择，原因如下：

- 它可能为用户提供最大的自由度。
- 小方块模板只需定义一次且可重复使用，因此即使创建过程稍复杂也无大碍。
- 这可能会减少实现所需的时间。
- 通过这种方式分享小方块模板会更容易。

#### 与时间相关的修改

对 QEC 码演化的编码（例如移动已编码量子比特、通过测量之间的关系获得检测事件等）可能需要另一种专门的数据结构，这需要由团队进一步研究和开发。

### 外部资源

**开源二维游戏创建库：**

- [https://ldtk.io/](https://ldtk.io/)
- [https://ogmo-editor-3.github.io/](https://ogmo-editor-3.github.io/)
- Reddit 上关于二维游戏创建库的帖子。

**用于表示量子计算的开源库：**
以下库可能有助于高效表示整个 QEC 循环。它们可能有些“杀鸡用牛刀”或不完全适用，但我仍将它们记录下来供大家参考：

- [https://github.com/CQCL/tierkreis](https://github.com/CQCL/tierkreis) —— 可用于表示代码、测量以及后续经典处理以获得检测事件之间的复杂关系。
- [https://github.com/CQCL/hugr](https://github.com/CQCL/hugr) —— 可用于以抽象方式表示 TQEC 所需的操作，并且应能与 tierkreis 很好地结合使用。

**（丑陋的）思路草图：**
（Njmm）
（如果有人在阅读彩色文本时有问题，请告知。）

此外，在主编辑器底部增加一个时间线查看器来编辑/显示不同时刻的代码可能也是个不错的主意（例如查看逻辑量子比特在网格上的位移）。

---

（John Long，负责以下段落及后续照片/草图）
考虑到存在多个层次（初始化层）、第 2 层（多轮测量）、以及第 3 层（最终数据量子比特读出），再加上量子比特的位移（或者其他更高层次的、与时间相关的移动目标，例如晶格手术），如果能有类似 Mac “时间机器”视图来查看逻辑量子比特，那将非常理想：

（示意图：Bnkk）

关于游戏引擎，有可能做出类似于臭名昭著的《5D 国际象棋与多元时空旅行》那样的功能，不过对象换成我们的逻辑量子比特。

---

## 设计方案 #2

在我（Gian Giacomo Guerreschi）看来，设计工具时需要考虑以下几点：

- **范围：**
  - 适用性：仅针对表面码，还是适用于通用稳定子码？
  - 灵活性：是否假设物理量子比特之间具有本地连通性？
  - 规模：是针对大约 10-30 个稳定子的小型原型，还是大约 100-1000 个稳定子的系统？
- **用户：**
  - 用户是谁？
  - 他们是否精通编码和/或数学？

例如，假设工具仅面向表面码、运行在具有本地连通性设备上、目标为大距离码，并且用户熟悉 Python 编程……那么我建议采用较少视觉化的方式输入信息。例如，仅提供一份稳定子列表来构建代码，然后工具自动更新可视化内容。

介于两者之间的方案可能是：提供一个包含所有相关函数的 Python 模块，并配以一个小型 GUI，以降低采纳门槛，同时直观地确认工具的运行情况。

部分想法的快速实现（分支自 TQEC 仓库，因为我无法创建新分支）：
[https://github.com/giangiac/tqec/tree/making-plaquettes](https://github.com/giangiac/tqec/tree/making-plaquettes)

---

## 考虑的替代方案

请务必讨论各替代方案相对于您的方案的优缺点。

---

## 依赖关系

**依赖项目：**
是否依赖于其他开源项目？

- 小方块（Plaquette）

---

## 工程影响

- 谁来维护这段代码？
- 这段代码是否构成独立可构建的单元？
- 能否对这段代码进行单独测试？
- 是否对外部仅暴露了一个小的 API 接口？

---

## 环境

**执行环境**
该功能是否仅适用于模拟器，还是也能在实际设备上运行？

---

## 最佳实践

如何使用/开发 TQEC 的最佳实践是什么？这些改动将如何传达或强制执行？

（John Long）
在开发 TQEC 过程中，应该制定一系列测试用例（“单元测试”），以确保从最简单情况到更复杂组合情况的最低功能要求都能得到满足。这可以确保开发进程顺利，并保证产品始终稳健（例如，确保某人引入改动后不会破坏已有功能）。例如：

- **瓷砖生成：** 确保扩展后的用户自定义小方块几何结构遵循明确定义的行为。
- **小方块“降低”/“编译”：** 能否从一个小方块得到有效的稳定子码？
- **逻辑量子比特操作：** 我们的量子比特扩展/移动操作在小规模（例如距离为 3 的量子比特）下是否合理？

单元测试只能覆盖部分内容。鉴于该工具将包含 UI 组件，可能还需要引入人工测试（QA 角色）以确保代码改动未导致 UI 退化。

---

## 教程和示例

TQEC 将如何被使用？

---

## 详细设计

这一部分对于早期提议可能是可选的。如果细节对理解设计非常重要而又使得上文的提议部分难以阅读，可以在此详细展开。

- 可能需要构建一种编译流水线，从可视化、用户交互友好的表示转换为一种中间表示（IR），再转换为实际执行逻辑量子比特的代码。
- 需要记住的是，如果您打算移动逻辑量子比特或改变其形状，用户可能需要在工作区中预定义“备用”量子比特，供逻辑量子比特在移动或变形时消耗或释放。用户甚至可能希望在继续调试时扩展工作区。

---

## 问题与讨论话题

请在此提出您在设计过程中需要反馈的开放性问题。

---
